<!DOCTYPE html>
<meta charset="UTF-8">
<html>
  <head>
    <title>Compute Pressure Demo</title>
    <!-- Chrome origin trial token -->
    <meta http-equiv="origin-trial" content="AkQevalWmBczMoMwX9h5kb7teecrlJpkjDvGRQTgVVSmmHdTTHVcwYT42CUi6Z31ejoxx30kaRxVE0vzhcMURQ0AAABZeyJvcmlnaW4iOiJodHRwczovL3czYy5naXRodWIuaW86NDQzIiwiZmVhdHVyZSI6IkNvbXB1dGVQcmVzc3VyZV92MiIsImV4cGlyeSI6MTcwNDQxMjc5OX0=">
  </head>
  <style>
    body {
        font-family: Arial, sans-serif;
        margin: 3em 3em;
    }

    #status {
      margin-bottom: 1em;
    }
    .enabled {
      color: green;
    }
    .disabled {
      color: red;
    }

    #emoji {
      font-size: 10em;
    }

    #wrapper {
      width: 600px;
      height: 400px;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #wrapper > div {
      position: absolute;
      color: white;
      font-size: 8em;
    }
  </style>
  <body>
    <h1>Compute Pressure demo</h1>
    <div id="status">
      <label>API Status:</label> <span id="status-text">not available</span>
    </div>
    <input type=button id="switch" value="Start"></input>
    <input type=button id="calibrate" value="Calibrate"></input> <span id="rounds"></span>
    <div></div>
      <span id="emoji">
        ðŸ˜´
      </span>
      <span id="label">Not observing</span>
    </div>

    <br><br>
    <h1>Mandelbrot simulation</h1>
    <div>Start to create artificial pressure, add workers to increase further.</div>
    <br>
    <div id="wrapper" width="600" height="400">
      <canvas id="mandel" width="600" height="400"></canvas>
      <div id="counter">0</div>
    </div>
    <br>
    <button id="start">Start simulation</button>
    <button id="stop">Stop simulation</button>
    <button id="ww_add">Add worker</button>
    <button id="ww_sub">Remove worker</button>
    <br>
    <input id="scale" type="range" min="0.1" max="1" value="1" step="0.1">
    <br>
    <span id="what">Unknown</span>
    <br>
    <input id="sent" type="text"><input id="received" type="text">
    <br>
    <input id="message" type="text">
  </body>
  <script type="module">
    import { Mandelbrot, Animator } from "./mandelbrot.js";
    import { ByteView, MessageEncoder, toBinaryString } from "./binutils.js";
    import { PressureCalibrator } from "./pressure-calibrator.js";
    import { BitChannelObserver } from "./bit-channel-observer.js";

    const mandel = new Mandelbrot(document.getElementById("mandel"));
    const animator = new Animator(mandel);

    const setWorkerCount = count => {
      animator.setWorkerCount(count);
      animateCounter();
    }
    const workerCount = () => animator.workerCount();
    const currentScale = () => animator.currentScale();

    document.getElementById("start").onclick = () => setWorkerCount(1);
    document.getElementById("stop").onclick = () => setWorkerCount(0);
    document.getElementById("ww_add").onclick = () => setWorkerCount(workerCount() + 1);
    document.getElementById("ww_sub").onclick = () => setWorkerCount(workerCount() - 1);
    document.getElementById("scale").onchange = e => animator.setScale(event.target.value);

    const delay = 4_000;

    String.prototype.replaceAt = function(index, ch) {
      let str = this + "â–¡".repeat(Math.max(0, index + 1 - this.length));
      return ch ? str.replace(/./g, (c, i) => i == index ? ch : c) : str;
    }

    async function sendMessage(msg, zero, reset, one, delay) {
      const enc = new MessageEncoder();
      const bits = new ByteView(enc.encode(msg));

      const timeout = delay => new Promise(resolve => setTimeout(resolve, delay));

      while (true) {
        let i = 0;
        let lastDwordIndex = 0;
        for (let bit of bits) {
          let byteIndex = Math.floor(i++ / 8);
          let dwordIndex = byteIndex % 4;

          if (dwordIndex !== lastDwordIndex) {
            lastDwordIndex = dwordIndex;
            if ([0, 2].includes(dwordIndex)) {
              document.getElementById("sent").value = "";
            } else {
              document.getElementById("sent").value += " ";
            }
          }
          document.getElementById("sent").value += `${bit}`;

          let byte = bits.u8[byteIndex];
          let chkByte = bits.u8[byteIndex + 1];
          switch (dwordIndex) {
            case 0: {
              let pos = byte - 128;
              document.getElementById("what").innerText = `position: ${pos} (${toBinaryString(byte)}) + checksum (${toBinaryString(chkByte)})`;
              break;
            }
            case 1:
            case 3:
              break;
            case 2: {
              const dec = new TextDecoder("utf-8");
              const ch = dec.decode(bits.buffer.slice(byteIndex, byteIndex + 1));
              document.getElementById("what").innerText = `character: '${ch}' (${toBinaryString(byte)}) + checksum (${toBinaryString(chkByte)})`;
              break;
            }
          }

          //console.log(`Sending ${bit}`);
          setWorkerCount(bit ? one : zero);
          await timeout(delay);

          console.log("Sending 'reset'");
          setWorkerCount(reset);
          await timeout(2*delay);
        }
      }
    }

    let msgReceived = "";
    let recView = new ByteView(new ArrayBuffer(2));
    let idx = 0;
    let align = 0;
    let position = -1;
    const dec = new TextDecoder("utf-8");

    const receiver = new BitChannelObserver(bit => {
      console.log("Received", bit);
      recView.setBit(idx, bit);

      document.getElementById("received").value += `${bit}`;

      if (idx !== 15) {
        idx++;
        return;
      }

      if (recView.validate()) {
        if (recView.getBit(0) === 1) { // Indicates position, we ignore extended ASCII
          recView.setBit(0, 0);
          position = recView.u8[0];
          console.log(`Received position ${position}`);
          // Resize string if chars are missing.
          msgReceived = msgReceived.replaceAt(position, "");
        } else if (position > -1) {
          const res = dec.decode(recView.buffer.slice(0, 1));
          msgReceived = msgReceived.replaceAt(position, res);
          console.log(`char: ${res} at pos: ${position}, msg: "${msgReceived}"`);
          position = -1;
        }
        document.getElementById("message").value = msgReceived;
        recView.clear();
        idx = align = 0;
        document.getElementById("received").value = "";
      } else {
        console.log(`Misaligned or corrupt data, shifting to find new alignment (${++align})...`);
        recView.shift16Left(1);
      }
    });

    const elem = document.querySelector("#status-text");

    const emoji = document.getElementById("emoji");
    const label = document.getElementById("label");
    const canvas = document.getElementById("mandel");
    const counter = document.getElementById("counter");

    const animateCounter = () => {
      const el = document.createElement("div");
      counter.innerText = workerCount();
      el.innerText = workerCount();
      canvas.insertAdjacentElement("afterend", el);

      const animation = [
        { opacity: 1, transform: 'translateY(0px) translateX(0px) scale(1)' },
        { opacity: 0, transform: `translateY(-200px) translateX(${Math.random() * 300 -150}px) scale(0.4)` }
      ];

      const timing = {
        duration: 600,
        iterations: 1,
      }
      el.animate(animation, timing).finished.then(() => el.remove());
    }

    const run = () => {
      const observer = new PressureObserver(changes => {
        switch(changes[0].state) {
          case "nominal":
            emoji.innerText = "ðŸ˜Œ";
            label.innerText = "Nominal pressure";
            break;
          case "fair":
            emoji.innerText = "ðŸ˜„";
            label.innerText = "Fair pressure";
            break;
          case "serious":
            emoji.innerText = "ðŸ˜–";
            label.innerText = "Serious pressure";
            break;
          case "critical":
            emoji.innerText = "ðŸ¥µ";
            label.innerText = "Critical pressure";
            break;
          default:
            emoji.innerText = "ðŸ˜´";
            label.innerText = "Not observing";
        }
      });

      const btn = document.getElementById("switch");
      btn.onclick = async ev => {
        if (ev.target.value == "Start") {
          ev.target.disabled = true;
          await observer.observe("cpu");
          ev.target.value = "Stop";
          ev.target.disabled = false;
        } else {
          observer.unobserve("cpu");
          ev.target.value = "Start";
          emoji.innerText = "ðŸ˜´";
          label.innerText = "Not observing";
        }
      };

      const calibrateBtn = document.getElementById("calibrate");
      calibrateBtn.onclick = async ev => {
        calibrateBtn.disabled = true;
        document.getElementById("wrapper").style = "display: none";
        const wakeLock = await navigator.wakeLock.request("screen");

        const calibrator = new PressureCalibrator(setWorkerCount);

        let config = await calibrator.calibrate();
        console.log(JSON.stringify(config));

        sendMessage("hello world", config.zero, config.reset, config.one, config.delay);
        receiver.observe();
      }
    }

    if (!("PressureObserver" in window)) {
      elem.innerText = "not available";
      elem.classList.add("disabled");
    } else {
      elem.innerText = "enabled";
      elem.classList.add("enabled");
      run();
    }
  </script>
</html>