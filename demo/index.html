<!DOCTYPE html>
<meta charset="UTF-8">
<html>
  <head>
    <title>Compute Pressure Demo</title>
    <!-- Chrome origin trial token -->
    <meta http-equiv="origin-trial" content="AkQevalWmBczMoMwX9h5kb7teecrlJpkjDvGRQTgVVSmmHdTTHVcwYT42CUi6Z31ejoxx30kaRxVE0vzhcMURQ0AAABZeyJvcmlnaW4iOiJodHRwczovL3czYy5naXRodWIuaW86NDQzIiwiZmVhdHVyZSI6IkNvbXB1dGVQcmVzc3VyZV92MiIsImV4cGlyeSI6MTcwNDQxMjc5OX0=">
  </head>
  <style>
    body {
        font-family: Arial, sans-serif;
        margin: 3em 3em;
    }

    #status {
      margin-bottom: 1em;
    }
    .enabled {
      color: green;
    }
    .disabled {
      color: red;
    }

    #emoji {
      font-size: 10em;
    }

    #wrapper {
      width: 600px;
      height: 400px;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #wrapper > div {
      position: absolute;
      color: white;
      font-size: 8em;
    }
  </style>
  <body>
    <h1>Compute Pressure demo</h1>
    <div id="status">
      <label>API Status:</label> <span id="status-text">not available</span>
    </div>
    <input type=button id="switch" value="Start"></input>
    <input type=button id="calibrate" value="Calibrate"></input> <span id="rounds"></span>
    <div></div>
      <span id="emoji">
        ðŸ˜´
      </span>
      <span id="label">Not observing</span>
    </div>

    <br><br>
    <h1>Mandelbrot simulation</h1>
    <div>Start to create artificial pressure, add workers to increase further.</div>
    <br>
    <div id="wrapper" width="600" height="400">
      <canvas id="mandel" width="600" height="400"></canvas>
      <div id="counter">0</div>
    </div>
    <br>
    <button id="start">Start simulation</button>
    <button id="stop">Stop simulation</button>
    <button id="ww_add">Add worker</button>
    <button id="ww_sub">Remove worker</button>
    <br>
    <input id="scale" type="range" min="0.1" max="1" value="1" step="0.1">
    <br>
    <span id="what">Unknown</span>
    <br>
    <input id="sent" type="text"><input id="received" type="text">
    <br>
    <input id="message" type="text">
  </body>
  <script type="module">
    import { Mandelbrot, Animator } from "./mandelbrot.js";
    import { ByteView, reverseByte, toBinaryString } from "./binutils.js";
    import { BitChannelObserver } from "./bit-channel-observer.js";

    const mandel = new Mandelbrot(document.getElementById("mandel"));
    const animator = new Animator(mandel);

    const setWorkerCount = count => {
      animator.setWorkerCount(count);
      animateCounter();
    }
    const workerCount = () => animator.workerCount();
    const currentScale = () => animator.currentScale();

    document.getElementById("start").onclick = () => setWorkerCount(1);
    document.getElementById("stop").onclick = () => setWorkerCount(0);
    document.getElementById("ww_add").onclick = () => setWorkerCount(workerCount() + 1);
    document.getElementById("ww_sub").onclick = () => setWorkerCount(workerCount() - 1);
    document.getElementById("scale").onchange = e => animator.setScale(event.target.value);

    const delay = 4_000;
    const limits = [];

    String.prototype.replaceAt = function(index, ch) {
      let str = this + "â–¡".repeat(Math.max(0, index + 1 - this.length));
      return ch ? str.replace(/./g, (c, i) => i == index ? ch : c) : str;
    }

    async function sendMessage(msg, zero, reset, one, delay) {
      const enc = new TextEncoder("utf-8");

      // We send 32 bits per ASCII character:
      //   |position| with the first bit set to 1 indicating a position
      //   |checksum| and alignment byte for the position
      //   |value| Non extended ASCII character
      //   |checksum| and alignment byte for the value
      //
      // A checksum is the reversed complement, e.g for 0110 1000
      // the complement will be 10010111 and reversed it will be 11101001
      let text = [...enc.encode(msg)].flatMap((value, position) => {
        const pos = position | 0b10000000;
        const vPos = reverseByte(~pos);
        const vValue = reverseByte(~value)
        console.log([
          toBinaryString(pos), toBinaryString(vPos),
          toBinaryString(value), toBinaryString(vValue)
        ]);
        return [ pos, vPos, value, vValue ]
      })

      const bits = new ByteView(new Uint8Array([...text]));

      const timeout = delay => new Promise(resolve => setTimeout(resolve, delay));

      while (true) {
        let i = 0;
        let lastDwordIndex = 0;
        for (let bit of bits) {
          let byteIndex = Math.floor(i++ / 8);
          let dwordIndex = byteIndex % 4;

          if (dwordIndex !== lastDwordIndex) {
            lastDwordIndex = dwordIndex;
            if ([0, 2].includes(dwordIndex)) {
              document.getElementById("sent").value = "";
            } else {
              document.getElementById("sent").value += " ";
            }
          }
          document.getElementById("sent").value += `${bit}`;

          let byte = bits.u8[byteIndex];
          let chkByte = bits.u8[byteIndex + 1];
          switch (dwordIndex) {
            case 0: {
              let pos = byte - 128;
              document.getElementById("what").innerText = `position: ${pos} (${toBinaryString(byte)}) + checksum (${toBinaryString(chkByte)})`;
              break;
            }
            case 1:
            case 3:
              break;
            case 2: {
              const dec = new TextDecoder("utf-8");
              const ch = dec.decode(bits.buffer.slice(byteIndex, byteIndex + 1));
              document.getElementById("what").innerText = `character: '${ch}' (${toBinaryString(byte)}) + checksum (${toBinaryString(chkByte)})`;
              break;
            }
          }

          //console.log(`Sending ${bit}`);
          setWorkerCount(bit ? one : zero);
          await timeout(delay);

          console.log("Sending 'reset'");
          setWorkerCount(reset);
          await timeout(2*delay);
        }
      }
    }

    let msgReceived = "";
    let recView = new ByteView(new ArrayBuffer(2));
    let idx = 0;
    let align = 0;
    let position = -1;
    const dec = new TextDecoder("utf-8");

    const receiver = new BitChannelObserver(bit => {
      console.log("Received", bit);
      recView.setBit(idx, bit);

      document.getElementById("received").value += `${bit}`;

      if (idx !== 15) {
        idx++;
        return;
      }

      if (recView.validate()) {
        if (recView.getBit(0) === 1) { // Indicates position, we ignore extended ASCII
          recView.setBit(0, 0);
          position = recView.u8[0];
          console.log(`Received position ${position}`);
          // Resize string if chars are missing.
          msgReceived = msgReceived.replaceAt(position, "");
        } else if (position > -1) {
          const res = dec.decode(recView.buffer.slice(0, 1));
          msgReceived = msgReceived.replaceAt(position, res);
          console.log(`char: ${res} at pos: ${position}, msg: "${msgReceived}"`);
          position = -1;
        }
        document.getElementById("message").value = msgReceived;
        recView.clear();
        idx = align = 0;
        document.getElementById("received").value = "";
      } else {
        console.log(`Misaligned or corrupt data, shifting to find new alignment (${++align})...`);
        recView.shift16Left(1);
      }
    });

    const elem = document.querySelector("#status-text");

    const emoji = document.getElementById("emoji");
    const label = document.getElementById("label");
    const canvas = document.getElementById("mandel");
    const counter = document.getElementById("counter");

    const animateCounter = () => {
      const el = document.createElement("div");
      counter.innerText = workerCount();
      el.innerText = workerCount();
      canvas.insertAdjacentElement("afterend", el);

      const animation = [
        { opacity: 1, transform: 'translateY(0px) translateX(0px) scale(1)' },
        { opacity: 0, transform: `translateY(-200px) translateX(${Math.random() * 300 -150}px) scale(0.4)` }
      ];

      const timing = {
        duration: 600,
        iterations: 1,
      }
      el.animate(animation, timing).finished.then(() => el.remove());
    }

    const run = () => {
      const observer = new PressureObserver(changes => {
        switch(changes[0].state) {
          case "nominal":
            emoji.innerText = "ðŸ˜Œ";
            label.innerText = "Nominal pressure";
            break;
          case "fair":
            emoji.innerText = "ðŸ˜„";
            label.innerText = "Fair pressure";
            break;
          case "serious":
            emoji.innerText = "ðŸ˜–";
            label.innerText = "Serious pressure";
            break;
          case "critical":
            emoji.innerText = "ðŸ¥µ";
            label.innerText = "Critical pressure";
            break;
          default:
            emoji.innerText = "ðŸ˜´";
            label.innerText = "Not observing";
        }
      });

      const btn = document.getElementById("switch");
      btn.onclick = async ev => {
        if (ev.target.value == "Start") {
          ev.target.disabled = true;
          await observer.observe("cpu");
          ev.target.value = "Stop";
          ev.target.disabled = false;
        } else {
          observer.unobserve("cpu");
          ev.target.value = "Start";
          emoji.innerText = "ðŸ˜´";
          label.innerText = "Not observing";
        }
      };

      const calibrateBtn = document.getElementById("calibrate");
      calibrateBtn.onclick = async ev => {
        calibrateBtn.disabled = true;
        document.getElementById("wrapper").style = "display: none";
        const wakeLock = await navigator.wakeLock.request("screen");

        const start = () => document.getElementById("start").click();
        const stop = () => document.getElementById("stop").click();
        const add = () => document.getElementById("ww_add").click();
        const remove = () => document.getElementById("ww_sub").click();
        let fn = add;

        const MEASURE_TIME = 10_000;

        const calibrate = async () => {
          let timerId = 0;
          let measure = [];
          let lastState;
          let countDown = 2;

          console.log(`Calibrating for ${MEASURE_TIME/1000}sec with ${workerCount()} workers at scale ${currentScale()}`);
          let now = performance.now();

          const report = state => {
            let prevState = lastState;
            lastState = state;
            if (prevState) {
              let lastTime = now;
              now = performance.now();

              if (!measure[workerCount()]) {
                measure[workerCount()] = {
                  "nominal": 0,
                  "fair": 0,
                  "serious": 0,
                  "critical": 0
                };
              }
              measure[workerCount()][prevState] += ((now - lastTime) / MEASURE_TIME);
            }
          }

          let done = false;

          return new Promise(resolve => {
            return resolve({ zero: 0, reset: 5, one: 8, delay: delay});

            timerId = setInterval(() => {

              if (lastState) {
                // Always inherit the latest state as you might see no changes
                // with this worker count.
                report(lastState);
                console.log(`${workerCount()} workers at scale ${currentScale()}: ${JSON.stringify(measure[workerCount()], null, "  ")}`);
                done = measure[workerCount()]["critical"] > 0.99;
              }

              fn();
              console.log(`Calibrating for ${MEASURE_TIME/1000}sec with ${workerCount()} workers at scale ${currentScale()}`);

              if (done) {
                clearInterval(timerId);
                calibrator.disconnect();

                let result = {
                  nominal: null, nominalPercentage: 0,
                  fair: null, fairPercentage: 0,
                  serious: null, seriousPercentage: 0,
                  critical: null, criticalPercentage: 0
                }

                for (let count in measure) {
                  let nominal = measure[count].nominal;
                  if (nominal > result.nominalPercentage) {
                    result.nominal = +count;
                    result.nominalPercentage = nominal;
                  }
                  let fair = measure[count].fair;
                  if (fair > result.fairPercentage) {
                    result.fair = +count;
                    result.fairPercentage = fair;
                  }
                  let serious = measure[count].serious;
                  if (serious > result.seriousPercentage) {
                    result.serious = +count;
                    result.seriousPercentage = serious;
                  }
                  let critical = measure[count].critical;
                  if (critical > result.criticalPercentage) {
                    result.critical = +count;
                    result.criticalPercentage = critical;
                  }
                }

                console.log("calculated", JSON.stringify(result));
                resolve({ zero: 0, reset: result.serious, one: result.critical, delay: delay});
              }
            }, MEASURE_TIME);

            const calibrator = new PressureObserver(changes => report(changes[0].state));

            calibrator.observe("cpu");
          });
        };

        calibrate().then(async config => {
          console.log(JSON.stringify(config));
          sendMessage("hello world", config.zero, config.reset, config.one, config.delay);
          await receiver.observe();
        });
      }
    }

    if (!("PressureObserver" in window)) {
      elem.innerText = "not available";
      elem.classList.add("disabled");
    } else {
      elem.innerText = "enabled";
      elem.classList.add("enabled");
      run();
    }
  </script>
</html>